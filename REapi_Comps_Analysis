# Script Name: REapi Comps Analysis
# Version: 2.1 (Linted)
# Created: 09-13-24
# Updated: 09-14-24
# Handles importing 1 subject property with multiple comps
# Next iteration: Handle multiple subject properties with multiple comps each, Async

import os
import json
from datetime import datetime
from math import radians, sin, cos, sqrt, atan2
from typing import Dict, Any, Tuple

import pandas as pd
import requests
from tqdm import tqdm

# Colab-specific imports
try:
    from google.colab import files, userdata
except ImportError:
    print("Running outside of Colab environment")

# Constants
OUTPUT_FOLDER = '/content/drive/MyDrive/REapi_Comps_Results'
COLAB_OUTPUT_FOLDER = '/content/REapi_Comps_Results'

FIELDS_TO_KEEP = [
    'address', 'bedrooms', 'bathrooms', 'yearBuilt', 'squareFeet', 'lotSquareFeet',
    'lastSaleDate', 'lastSaleAmount', 'estimatedValue', 'latitude', 'longitude'
]

def flatten_json(nested_json: Dict[str, Any], prefix: str = '') -> Dict[str, Any]:
    """Recursively flatten a nested JSON structure."""
    flattened = {}
    for key, value in nested_json.items():
        new_key = f"{prefix}.{key}" if prefix else key
        if isinstance(value, dict):
            flattened.update(flatten_json(value, new_key))
        elif isinstance(value, list):
            for i, item in enumerate(value):
                if isinstance(item, dict):
                    flattened.update(flatten_json(item, f"{new_key}.{i}"))
                else:
                    flattened[f"{new_key}.{i}"] = item
        else:
            flattened[new_key] = value
    return flattened

def select_file() -> str:
    """List files and allow user to select or upload a file."""
    files_list = [f for f in os.listdir() if f.endswith(('.json', '.txt', '.csv', '.xlsx', '.xls'))]
    print("Available files:")
    for i, file in enumerate(files_list, 1):
        print(f"{i}. {file}")
    print(f"{len(files_list) + 1}. Upload a new file")

    while True:
        try:
            choice = int(input("Select a file number: "))
            if 1 <= choice <= len(files_list):
                return files_list[choice - 1]
            if choice == len(files_list) + 1:
                uploaded = files.upload()
                if uploaded:
                    return list(uploaded.keys())[0]
                print("No file was uploaded. Please try again.")
            else:
                print("Invalid choice. Please try again.")
        except ValueError:
            print("Invalid input. Please enter a number.")

def import_data(file_path: str) -> Tuple[Dict[str, Any], pd.DataFrame]:
    """Import data from various file formats, including JSON in .txt files."""
    if file_path.endswith(('.json', '.txt')):
        with open(file_path, 'r') as f:
            try:
                data = json.load(f)
            except json.JSONDecodeError:
                # If JSON decoding fails, try to read as plain text
                f.seek(0)
                text_content = f.read()
                # Attempt to parse the text content as JSON
                try:
                    data = json.loads(text_content)
                except json.JSONDecodeError:
                    raise ValueError(f"Unable to parse JSON from file: {file_path}")

        # Process the JSON data
        if 'comps' in data and 'input' in data:
            subject_data = data['input']
            flattened_data = [flatten_json(comp) for comp in data['comps']]
            df = pd.DataFrame(flattened_data)
            return subject_data, df
        raise ValueError("JSON does not contain 'comps' and 'input' keys")

    if file_path.endswith('.csv'):
        df = pd.read_csv(file_path)
    elif file_path.endswith(('.xlsx', '.xls')):
        df = pd.read_excel(file_path)
    else:
        raise ValueError("Unsupported file format")

    subject_data = df[df.columns[df.columns.str.startswith('subject_')]].iloc[0].to_dict()
    df = df.drop(columns=[col for col in df.columns if col.startswith('subject_')])
    return subject_data, df

def clean_data(df: pd.DataFrame) -> pd.DataFrame:
    """Clean and preprocess the data."""
    df = df.fillna(0)
    numeric_columns = [col for col in df.columns if any(field in col for field in [
        'bedrooms', 'bathrooms', 'yearBuilt', 'squareFeet', 'lotSquareFeet', 
        'lastSaleAmount', 'latitude', 'longitude'
    ])]
    for col in numeric_columns:
        df[col] = pd.to_numeric(df[col], errors='coerce')
    return df

def calculate_ppsf(df: pd.DataFrame) -> pd.DataFrame:
    """Calculate price per square foot."""
    df['price_per_sqft'] = df['lastSaleAmount'] / df['squareFeet']
    return df

def calculate_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float:
    """Calculate the distance between two points on Earth in miles."""
    radius = 3959  # Earth's radius in miles

    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])
    dlat = lat2 - lat1
    dlon = lon2 - lon1

    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2
    c = 2 * atan2(sqrt(a), sqrt(1-a))
    distance = radius * c

    return distance

def format_results(subject_data: Dict[str, Any], comps_data: pd.DataFrame, est_arv: float, avg_ppsf: float) -> pd.DataFrame:
    """Format the results into a DataFrame."""
    results = {
        'subject_address': subject_data.get('address', 'N/A'),
        'subject_beds': subject_data.get('bedrooms', 'N/A'),
        'subject_baths': subject_data.get('bathrooms', 'N/A'),
        'subject_year_built': subject_data.get('yearBuilt', 'N/A'),
        'subject_sqft': subject_data.get('squareFeet', 'N/A'),
        'subject_lot_size': subject_data.get('lotSquareFeet', 'N/A'),
        'est_arv': est_arv,
        'avg_ppsf': avg_ppsf,
        'num_comps': len(comps_data)
    }

    for i, comp in comps_data.iterrows():
        comp_prefix = f'comp_{i+1}_'
        results[f'{comp_prefix}address'] = comp.get('address.address', 'N/A')
        for field in FIELDS_TO_KEEP:
            if field != 'address':
                results[f'{comp_prefix}{field}'] = comp.get(field, 'N/A')
        results[f'{comp_prefix}distance_miles'] = comp.get('distance_from_subject', 'N/A')

    return pd.DataFrame([results])

def save_results(df: pd.DataFrame) -> None:
    """Save results to CSV in both Colab and Google Drive, and download to local machine."""
    timestamp = datetime.now().strftime("%m%d%y_%H%M%S")
    filename = f"REAPI_Comps_{timestamp}.csv"

    # Save in Colab environment
    colab_path = os.path.join(COLAB_OUTPUT_FOLDER, filename)
    os.makedirs(COLAB_OUTPUT_FOLDER, exist_ok=True)
    df.to_csv(colab_path, index=False)
    print(f"Results saved in Colab as {colab_path}")

    # Save to Google Drive
    drive_path = os.path.join(OUTPUT_FOLDER, filename)
    os.makedirs(OUTPUT_FOLDER, exist_ok=True)
    df.to_csv(drive_path, index=False)
    print(f"Results saved to Google Drive as {drive_path}")

    # Download to local machine
    files.download(colab_path)
    print(f"Results downloaded to your local machine as {filename}")
    print("Please check your browser's download folder for the file.")

def main():
    """Main execution function."""
    try:
        # File selection and data import
        file_path = select_file()
        subject_data, df = import_data(file_path)

        # Data cleaning and processing
        df = clean_data(df)
        df = calculate_ppsf(df)

        # Calculations
        avg_ppsf = df['price_per_sqft'].mean()
        subject_sqft = float(subject_data.get('squareFeet', 0))
        est_arv = avg_ppsf * subject_sqft if subject_sqft else 0

        # Distance calculation
        subject_lat = float(subject_data.get('latitude', 0))
        subject_lon = float(subject_data.get('longitude', 0))
        df['distance_from_subject'] = df.apply(
            lambda row: calculate_distance(
                subject_lat, subject_lon, 
                float(row['latitude']), float(row['longitude'])
            ), 
            axis=1
        )

        # Results formatting and saving
        results_df = format_results(subject_data, df, est_arv, avg_ppsf)
        save_results(results_df)

        # Print summary
        print(f"Processed {len(df)} comparable properties.")
        print(f"Estimated ARV: ${est_arv:.2f}")
        print(f"Average Price per Square Foot: ${avg_ppsf:.2f}")

    except Exception as e:
        print(f"An error occurred: {str(e)}")

if __name__ == "__main__":
    main()