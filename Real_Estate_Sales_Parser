# RealEstate_Sales_Parser
# Version 0.7

import pandas as pd
import re
import os
from google.colab import files
from google.colab import drive
from datetime import datetime
import pytz

# 1 - Constants
GOOGLE_DRIVE_FOLDER_ID = "1dq-zCFoHpl30_f7BRquB_q5wOJnQsxWL"

def mount_drive():
    """
    Mounts Google Drive to the Colab environment.
    """
    try:
        drive.mount('/content/drive')
    except Exception as e:
        print(f"An error occurred while mounting Google Drive: {e}")

# 4 - File listing and selection
def list_files_in_colab():
    """
    # 4.1 - List relevant files in the current Colab directory and provide an option to upload a new file
    Returns:
        list: A list of relevant filenames.
    """
    # 4.2 - Get all files in the current directory
    all_files = os.listdir('.')
    
    # 4.3 - Filter out system files and directories
    relevant_files = [f for f in all_files if not f.startswith('.') and not os.path.isdir(f)]
    
    # 4.4 - Print relevant files
    print("Relevant files available in the Colab environment:")
    for i, file_name in enumerate(relevant_files):
        print(f"{i + 1}. {file_name}")
    
    # 4.5 - Add upload option
    print(f"{len(relevant_files) + 1}. Upload a new file")
    
    return relevant_files

# 5 - User file selection
def get_user_file_selection(file_list):
    """
    # 5.1 - Prompt the user to select a file from the list or upload a new one
    Args:
        file_list (list): List of available filenames.
    Returns:
        str: Path to the selected or uploaded file.
    """
    while True:
        try:
            selected_option = int(input("Enter the number corresponding to the file you want to use: "))
            if 1 <= selected_option <= len(file_list):
                return file_list[selected_option - 1]
            elif selected_option == len(file_list) + 1:
                uploaded = files.upload()
                if uploaded:
                    return list(uploaded.keys())[0]
                else:
                    print("No file uploaded. Please try again.")
            else:
                print(f"Please enter a number between 1 and {len(file_list) + 1}.")
        except ValueError:
            print("Invalid input. Please enter a valid number.")

def read_file(file_path):
    """
    Reads the content of a file.
    Args:
        file_path (str): Path to the file.
    Returns:
        str: Content of the file.
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            data = file.read()
        return data
    except Exception as e:
        print(f"An error occurred while reading the file: {e}")
        return ""



def parse_data(data):
    """
    Parses the raw data using predefined regex patterns and returns a DataFrame.
    Handles multiple records separated by 'MLS#'.
    Returns:
        pd.DataFrame: Parsed data.
    """
    # Define regex patterns for various fields
    field_patterns = {
        'MLS#': r'MLS#\s*(\d+)',
        'DOM/CDOM': r'DOM/CDOM[:\t]+\s*([\d\/]+)',
        'Address': r'DOM/CDOM[:\t]+\s*[\d\/]+\s*([\d\w\s,]+,\s*[\w\s]+,\s*FL\s*\d{5})',
        'County': r'County[:\t]+\s*([\w\s]+)',
        'List Price': r'List Price[:\t]+\$?([\d,]+)',
        'Close Price': r'Close Price[:\t]+\$?([\d,]+)',
        'Year Built': r'Year Built[:\t]+\s*(\d+)',
        'Living Area': r'Living Area[:\t]+\$?([\d,]+)',
        'Bedrooms Total': r'Bedrooms Total[:\t]+\s*(\d+)',
        'Bathrooms Total': r'Bathrooms Total[:\t]+\s*(\d+)',
        'Garage Spaces': r'Garage Spaces[:\t]+\s*(\d+)',
        'Parcel Number': r'Parcel Number[:\t]+\s*(\d+)',
        'Subdivision Name': r'Subdivision Name[:\t]+\s*([\w\s]+)',
        'CDD Fee': r'CDD Fee[:\t]+\s*(Yes|No)',
        'New Construction': r'New Construction[:\t]+\s*(Yes|No)',
        'Waterfront': r'Waterfront[:\t]+\s*(Yes|No)',
        'Directions': r'Directions[:\t]+\s*([\w\s,\.]+)',
        'Public Remarks': r'Public Remarks[:\t]+\s*([\s\S]*?)\s*\nPrivate Remarks:',
        'Private Remarks': r'Private Remarks[:\t]+\s*([\s\S]*?)(?=\nAppliances:|$)',
        'Appliances': r'Appliances[:\t]+\s*([\w\s;,\-]+)',
        'Approx Parcel Size': r'Approx Parcel Size[:\t]+\s*([\w\s\.]+)',
        'Architectural Style': r'Architectural Style[:\t]+\s*([\w\s;,\-]+)',
        'Construction Materials': r'Construction Materials[:\t]+\s*([\w\s;,\-]+)',
        'Cooling': r'Cooling[:\t]+\s*([\w\s;,\-]+)',
        'Current Use': r'Current Use[:\t]+\s*([\w\s;,\-]+)',
        'DPR Eligible': r'DPR Eligible[:\t]+\s*([\w\s;,\-]*)',
        'Fencing': r'Fencing[:\t]+\s*([\w\s;,\-]+)',
        'Fireplace Features': r'Fireplace Features[:\t]+\s*([\w\s;,\-]+)',
        'Heating': r'Heating[:\t]+\s*([\w\s;,\-]+)',
        'Interior Features': r'Interior Features[:\t]+\s*([\w\s;,\-]+)',
        'Laundry Features': r'Laundry Features[:\t]+\s*([\w\s;,\-]+)',
        'Listing Terms': r'Listing Terms[:\t]+\s*([\w\s;,\-]+)',
        'Lot Features': r'Lot Features[:\t]+\s*([\w\s;,\-]+)',
        'Parking Features': r'Parking Features[:\t]+\s*([\w\s;,\-]+)',
        'Patio And Porch Features': r'Patio And Porch Features[:\t]+\s*([\w\s;,\-]+)',
        'Pool Features': r'Pool Features[:\t]+\s*([\w\s;,\-]+)',
        'Possession': r'Possession[:\t]+\s*([\w\s;,\-]+)',
        'Road Surface Type': r'Road Surface Type[:\t]+\s*([\w\s;,\-]+)',
        'Roof': r'Roof[:\t]+\s*([\w\s;,\-]+)',
        'Security Features': r'Security Features[:\t]+\s*([\w\s;,\-]+)',
        'Sewer': r'Sewer[:\t]+\s*([\w\s;,\-]+)',
        'Special Listing Conditions': r'Special Listing Conditions[:\t]+\s*([\w\s;,\-]+)',
        'Utilities': r'Utilities[:\t]+\s*([\w\s;,\-]+)',
        'Water Source': r'Water Source[:\t]+\s*([\w\s;,\-]+)',
        'Showing Requirements': r'Showing Requirements[:\t]+\s*([\w\s;,\-]+)',
        'Showing Considerations': r'Showing Considerations[:\t]+\s*([\w\s;,\-]+)',
        'Listing Contract Date': r'Listing Contract Date[:\t]+\s*([\d/]+)',
        'Purchase Contract Date': r'Purchase Contract Date[:\t]+\s*([\d/]+)',
        'Close Date': r'Close Date[:\t]+\s*([\d/]+)',
        'Listing Service': r'Listing Service[:\t]+\s*([\w\s]+)',
        'Original List Price': r'Original List Price[:\t]+\$?([\d,]+)',
        'List Price/SqFt': r'List Price/SqFt[:\t]+\$?([\d\.]+)',
        'Sold Price/SqFt': r'Sold Price/SqFt[:\t]+\$?([\d\.]+)',
        'Listing Agreement': r'Listing Agreement[:\t]+\s*([\w\s]+)',
        'Contingency Reason': r'Contingency Reason[:\t]+\s*([\w\s;,\-]+)',
        'Buyer Financing': r'Buyer Financing[:\t]+\s*([\w\s;,\-]+)',
        'Concessions': r'Concessions[:\t]+\s*(Yes|No)',
        'BuyersCountryReside': r'BuyersCountryReside[:\t]+\s*([\w\s]+)',
        'SellersCountryReside': r'SellersCountryReside[:\t]+\s*([\w\s]+)'
    }

    # Define separate regex patterns for LO, LA, SO, and SA
    lo_pattern = re.compile(
        r'(?:\n|\t)LO:\s*([^()]+)\s*\(Office:\)\s*([\d-]+)(?:\s*\(Fax:\)\s*([\d-]+))?\s*\(Email:\)\s*([\w\@\.\+\-]+)',
        re.IGNORECASE
    )
    la_pattern = re.compile(
        r'(?:\n|\t)LA:\s*([^()]+)\s*\(Phone:\)\s*([\d-]+)\s*\(Office:\)\s*([\d-]+)(?:\s*\(Fax:\)\s*([\d-]+))?\s*\(Email:\)\s*([\w\@\.\+\-]+)',
        re.IGNORECASE
    )
    so_pattern = re.compile(
        r'(?:\n|\t)SO:\s*([^()]+)\s*\(Office:\)\s*([\d-]+)(?:\s*\(Fax:\)\s*([\d-]+))?\s*\(Email:\)\s*([\w\@\.\+\-]+)',
        re.IGNORECASE
    )
    sa_pattern = re.compile(
        r'(?:\n|\t)SA:\s*([^()]+)\s*\(Office:\)\s*([\d-]+)\s*\(Email:\)\s*([\w\@\.\+\-]+)',
        re.IGNORECASE
    )

    # Split records by 'MLS#', keeping 'MLS#' with the split records
    records = re.split(r'(MLS#\s*\d+)', data)
    # The first element is before the first 'MLS#', likely irrelevant, remove it
    if records and not re.search(r'MLS#\s*\d+', records[0]):
        records = records[1:]
    # Now, pair 'MLS#' with the corresponding record content
    paired_records = []
    for i in range(0, len(records), 2):
        mls = records[i].strip()
        content = records[i+1].strip() if i+1 < len(records) else ''
        if mls and content:
            paired_records.append(mls + "\n" + content)

    parsed_records = []

    for record in paired_records:
        record_data = {}
        # Extract fields
        for field_name, pattern in field_patterns.items():
            match = re.search(pattern, record, re.DOTALL)
            if match:
                # For numeric fields, remove commas
                if field_name in ['List Price', 'Close Price', 'Living Area', 'Bedrooms Total', 
                                  'Bathrooms Total', 'Garage Spaces', 'Parcel Number', 'Original List Price']:
                    record_data[field_name] = match.group(1).replace(',', '')
                elif field_name in ['Concessions', 'CDD Fee', 'New Construction', 'Waterfront']:
                    # Normalize Yes/No to consistent casing
                    record_data[field_name] = match.group(1).strip().capitalize()
                else:
                    record_data[field_name] = match.group(1).strip()
            else:
                record_data[field_name] = ''

        # Extract LO, LA, SO, SA details
        lo_match = lo_pattern.search(record)
        la_match = la_pattern.search(record)
        so_match = so_pattern.search(record)
        sa_match = sa_pattern.search(record)

        record_data['LO Name'] = lo_match.group(1).strip() if lo_match else ''
        record_data['LO Office'] = lo_match.group(2).strip() if lo_match else ''
        record_data['LO Fax'] = lo_match.group(3).strip() if lo_match and lo_match.group(3) else ''
        record_data['LO Email'] = lo_match.group(4).strip() if lo_match else ''

        record_data['LA Name'] = la_match.group(1).strip() if la_match else ''
        record_data['LA Phone'] = la_match.group(2).strip() if la_match else ''
        record_data['LA Office'] = la_match.group(3).strip() if la_match else ''
        record_data['LA Fax'] = la_match.group(4).strip() if la_match and la_match.group(4) else ''
        record_data['LA Email'] = la_match.group(5).strip() if la_match else ''

        record_data['SO Name'] = so_match.group(1).strip() if so_match else ''
        record_data['SO Office'] = so_match.group(2).strip() if so_match else ''
        record_data['SO Fax'] = so_match.group(3).strip() if so_match and so_match.group(3) else ''
        record_data['SO Email'] = so_match.group(4).strip() if so_match else ''

        record_data['SA Name'] = sa_match.group(1).strip() if sa_match else ''
        record_data['SA Office'] = sa_match.group(2).strip() if sa_match else ''
        record_data['SA Email'] = sa_match.group(3).strip() if sa_match else ''

        parsed_records.append(record_data)

    df = pd.DataFrame(parsed_records)
    return df




def save_to_google_drive(df, folder_id, filename='parsed_sales_data.csv'):
    """
    # 2.1 - Save DataFrame to a specified folder in Google Drive using folder ID
    Args:
        df (pd.DataFrame): The DataFrame to save.
        folder_id (str): ID of the folder in Google Drive.
        filename (str): Base filename for the saved CSV.
    """
    try:
        # 2.2 - Get current date and time in EST
        est = pytz.timezone('America/New_York')
        current_time = datetime.now(est)
        timestamp = current_time.strftime("%m%d%y-%H%M%S")
        
        # 2.3 - Create the new filename with formatted date and time
        base_name, extension = os.path.splitext(filename)
        new_filename = f"{base_name}_{timestamp}{extension}"
        
        # 2.4 - Save the file to the specified folder using folder ID
        from google.colab import auth
        from googleapiclient.discovery import build
        from googleapiclient.http import MediaFileUpload
        
        auth.authenticate_user()
        drive_service = build('drive', 'v3')
        
        file_metadata = {
            'name': new_filename,
            'parents': [folder_id]
        }
        
        # 2.5 - Save DataFrame to a temporary CSV file
        temp_csv_path = f'/tmp/{new_filename}'
        df.to_csv(temp_csv_path, index=False)
        
        media = MediaFileUpload(temp_csv_path, resumable=True)
        file = drive_service.files().create(body=file_metadata, media_body=media, fields='id').execute()
        
        print(f"File saved successfully with ID: {file.get('id')}")
    except Exception as e:
        print(f"An error occurred while saving the file to Google Drive: {e}")

def download_parsed_data(df, filename='parsed_sales_data.csv'):
    """
    Saves the DataFrame locally and initiates a download in Colab.
    Args:
        df (pd.DataFrame): The DataFrame to download.
        filename (str): The name of the file to save and download.
    """
    try:
        # 6.2 - Get current date and time in EST
        est = pytz.timezone('America/New_York')
        current_time = datetime.now(est)
        timestamp = current_time.strftime("%m%d%y-%H%M%S")
        
        # 6.3 - Create the new filename with formatted date and time
        base_name, extension = os.path.splitext(filename)
        new_filename = f"{base_name}_{timestamp}{extension}"
        
        # 6.4 - Save and download the file
        df.to_csv(new_filename, index=False)
        print(f"File saved locally as {new_filename}. Initiating download...")
        files.download(new_filename)
    except Exception as e:
        print(f"An error occurred during the download: {e}")

def main():
    # 3.1 - Mount Google Drive
    mount_drive()
    
    # 3.2 - File selection
    file_list = list_files_in_colab()
    file_path = get_user_file_selection(file_list)
    
    # 3.3 - Read and parse data
    data = read_file(file_path)
    if not data:
        print("No data to parse. Exiting.")
        return
    parsed_data = parse_data(data)
    
    # 3.4 - Save to Google Drive using folder ID
    save_to_google_drive(parsed_data, GOOGLE_DRIVE_FOLDER_ID)
    
    # 3.5 - Download the parsed data
    download_parsed_data(parsed_data)

if __name__ == "__main__":
    main()